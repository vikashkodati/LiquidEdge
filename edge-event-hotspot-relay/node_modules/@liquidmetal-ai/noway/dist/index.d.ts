import * as jose from 'jose';
import type { KvCache } from './kv_cache.js';
/**
 * Creates an origin validator from a list of allowed hostnames.
 *
 * This is a convenience function for the common case where you want to allow
 * JWKS fetching from a specific set of known hostnames. The returned validator
 * checks that URLs have a hostname matching one in the allowedHostnames array.
 *
 * @param allowedHostnames - Array of allowed hostnames (e.g., ['auth0.com', 'googleapis.com'])
 * @returns A validator function for use with NoWay originValidator option
 *
 * @example
 * ```typescript
 * // Simple list of allowed hostnames
 * const noway = new NoWay({
 *   kvCache,
 *   originValidator: originList(['auth0.com', 'okta.com', 'googleapis.com'])
 * });
 * ```
 *
 * @example
 * ```typescript
 * // For wildcard subdomain support, you still need a custom validator
 * const noway = new NoWay({
 *   kvCache,
 *   originValidator: (url) => {
 *     const hostname = new URL(url).hostname;
 *     return hostname.endsWith('.auth0.com') || hostname === 'auth0.com';
 *   }
 * });
 * ```
 */
export declare function originList(allowedHostnames: string[]): (url: string) => boolean;
export interface JwksResolverResult {
    url: string;
    jwks: {
        keys: jose.JWK[];
    };
}
export type JwksResolver = (context: JwksResolutionContext, validateOrigin: (url: string) => void) => Promise<JwksResolverResult | null>;
export interface NoWayOptions {
    kvCache: KvCache;
    keyPrefix?: string;
    defaultTtl?: number;
    /**
     * REQUIRED: Function to validate if a JWKS URL origin is allowed.
     * This prevents SSRF attacks by validating URLs from jku, iss discovery, and kid claims.
     * @param url - The full URL that would be fetched
     * @returns true if the origin is allowed, false otherwise
     * @example
     * // Use the convenience function for simple hostname lists
     * originValidator: originList(['auth0.com', 'googleapis.com', 'okta.com'])
     * @example
     * // Or write a custom validator for more complex rules
     * originValidator: (url) => {
     *   const parsed = new URL(url);
     *   return parsed.protocol === 'https:' &&
     *          parsed.hostname.endsWith('.auth0.com');
     * }
     */
    originValidator: (url: string) => boolean;
    /**
     * Array of JWKS resolver functions to try in order.
     * Each resolver attempts to find and fetch a JWKS from the token context.
     * Defaults to [jkuResolver, issuerDiscoveryResolver, kidUrlResolver].
     *
     * @example
     * // Use default resolution order (jku → iss → kid)
     * resolvers: undefined  // or omit this option
     *
     * @example
     * // Change resolution order
     * resolvers: [issuerDiscoveryResolver, jkuResolver]  // Try iss first, skip kid
     *
     * @example
     * // Add custom resolver
     * resolvers: [myCustomResolver, issuerDiscoveryResolver, jkuResolver]
     */
    resolvers?: JwksResolver[];
}
export interface JwtVerifyOptions {
    algorithms?: string[];
    audience?: string | string[];
    issuer?: string | string[];
    clockTolerance?: string | number;
}
export interface JwtSignOptions {
    algorithm?: string;
    expiresIn?: string | number;
    notBefore?: string | number;
    audience?: string | string[];
    issuer?: string;
    jti?: string;
    subject?: string;
    noTimestamp?: boolean;
    header?: jose.JWTHeaderParameters;
}
export interface CachedJwks {
    keys: jose.JWK[];
    cachedAt: number;
    expiresAt?: number;
    source: string;
    keyIds: string[];
    issuerContext?: string;
    resolvedMethod?: 'direct' | 'jku' | 'iss' | 'kid';
    resolvedUrl?: string;
}
export interface JwksResolutionContext {
    header?: jose.JWTHeaderParameters;
    payload?: jose.JWTPayload;
    iss?: string;
    kid?: string;
    jku?: string;
}
/**
 * Built-in resolver that tries to fetch JWKS from the jku (JWK Set URL) claim.
 * This is typically found in the JWT header.
 */
export declare const jkuResolver: JwksResolver;
/**
 * Built-in resolver that discovers JWKS URL from the issuer claim using OIDC discovery.
 * Implements RFC 8414 Section 4 (.well-known/openid-configuration).
 */
export declare const issuerDiscoveryResolver: JwksResolver;
/**
 * Built-in resolver that tries to fetch JWKS from the kid (Key ID) if it looks like a URL.
 * This is a legacy pattern where kid contains a full URL to the JWKS.
 */
export declare const kidUrlResolver: JwksResolver;
export declare class NoWay {
    private kvCache;
    private keyPrefix;
    private defaultTtl;
    private originValidator;
    private resolvers;
    constructor(options: NoWayOptions);
    private getCacheKey;
    private generateResolutionCacheKey;
    private validateOrigin;
    resolveJWKS(context: JwksResolutionContext, ttl?: number): Promise<jose.JWTVerifyGetKey>;
    private createCachedJWKSGetter;
    verifyJWT<T = jose.JWTPayload>(token: string, secret: string | Uint8Array | jose.KeyLike | jose.JWTVerifyGetKey, options?: JwtVerifyOptions): Promise<jose.JWTVerifyResult<T>>;
    verifyJWTWithJWKS<T = jose.JWTPayload>(token: string, options?: JwtVerifyOptions & {
        jwksTtl?: number;
    }): Promise<jose.JWTVerifyResult<T>>;
    /**
     * Get a JWTVerifyGetKey function for a token that can be used directly with jose.jwtVerify.
     * This allows users to leverage NoWay's JWKS resolution and caching while maintaining
     * full control over verification options.
     *
     * @param token - The JWT token to get the key getter for
     * @param options - Optional JWKS cache TTL
     * @returns A JWTVerifyGetKey function that can be passed to jose.jwtVerify
     *
     * @example
     * ```typescript
     * const noway = new NoWay({ kvCache, originValidator });
     * const getKey = await noway.getKeyGetter(token);
     *
     * // Use directly with jose
     * const result = await jose.jwtVerify(token, getKey, {
     *   audience: 'my-api',
     *   issuer: 'https://my-issuer.com'
     * });
     * ```
     */
    getKeyGetter(token: string, options?: {
        jwksTtl?: number;
    }): Promise<jose.JWTVerifyGetKey>;
    signJWT(payload: jose.JWTPayload, secret: string | Uint8Array | jose.KeyLike, options?: JwtSignOptions): Promise<string>;
    invalidateCache(key: string): Promise<void>;
    clearCache(): Promise<void>;
}
export { decodeJwt, decodeProtectedHeader, errors, type JWK, type JWTHeaderParameters, type JWTPayload, type JWTVerifyGetKey, type JWTVerifyResult, type KeyLike } from 'jose';
export default NoWay;
//# sourceMappingURL=index.d.ts.map