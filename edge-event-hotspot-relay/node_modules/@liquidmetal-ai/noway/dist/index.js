import * as jose from 'jose';
/**
 * Creates an origin validator from a list of allowed hostnames.
 *
 * This is a convenience function for the common case where you want to allow
 * JWKS fetching from a specific set of known hostnames. The returned validator
 * checks that URLs have a hostname matching one in the allowedHostnames array.
 *
 * @param allowedHostnames - Array of allowed hostnames (e.g., ['auth0.com', 'googleapis.com'])
 * @returns A validator function for use with NoWay originValidator option
 *
 * @example
 * ```typescript
 * // Simple list of allowed hostnames
 * const noway = new NoWay({
 *   kvCache,
 *   originValidator: originList(['auth0.com', 'okta.com', 'googleapis.com'])
 * });
 * ```
 *
 * @example
 * ```typescript
 * // For wildcard subdomain support, you still need a custom validator
 * const noway = new NoWay({
 *   kvCache,
 *   originValidator: (url) => {
 *     const hostname = new URL(url).hostname;
 *     return hostname.endsWith('.auth0.com') || hostname === 'auth0.com';
 *   }
 * });
 * ```
 */
export function originList(allowedHostnames) {
    return (url) => {
        try {
            const hostname = new URL(url).hostname;
            return allowedHostnames.includes(hostname);
        }
        catch {
            return false;
        }
    };
}
/**
 * Helper function to discover JWKS URL from an OIDC issuer.
 * Implements RFC 8414 Section 4 (.well-known/openid-configuration discovery).
 */
async function discoverJwksUrl(issuer, validateOrigin) {
    try {
        // Validate the OpenID Connect configuration URL origin
        validateOrigin(issuer);
        // Per RFC 8414 Section 4: append .well-known/openid-configuration to the issuer
        const wellKnownUrl = issuer.endsWith('/')
            ? `${issuer}.well-known/openid-configuration`
            : `${issuer}/.well-known/openid-configuration`;
        const response = await fetch(wellKnownUrl);
        if (!response.ok) {
            return null;
        }
        const config = await response.json();
        const jwksUrl = config.jwks_uri;
        if (jwksUrl) {
            // Validate the discovered jwks_uri to prevent SSRF
            validateOrigin(jwksUrl);
        }
        return jwksUrl || null;
    }
    catch (error) {
        // Re-throw origin validation errors - don't swallow them
        if (error instanceof Error && error.message.includes('JWKS URL origin not allowed')) {
            throw error;
        }
        // Return null for other errors (network issues, invalid JSON, etc.)
        return null;
    }
}
/**
 * Built-in resolver that tries to fetch JWKS from the jku (JWK Set URL) claim.
 * This is typically found in the JWT header.
 */
export const jkuResolver = async (context, validateOrigin) => {
    if (!context.jku)
        return null;
    validateOrigin(context.jku);
    const response = await fetch(context.jku);
    if (!response.ok)
        return null;
    const jwks = await response.json();
    if (!jwks.keys || !Array.isArray(jwks.keys))
        return null;
    return { url: context.jku, jwks };
};
/**
 * Built-in resolver that discovers JWKS URL from the issuer claim using OIDC discovery.
 * Implements RFC 8414 Section 4 (.well-known/openid-configuration).
 */
export const issuerDiscoveryResolver = async (context, validateOrigin) => {
    if (!context.iss)
        return null;
    validateOrigin(context.iss);
    const jwksUrl = await discoverJwksUrl(context.iss, validateOrigin);
    if (!jwksUrl)
        return null;
    const response = await fetch(jwksUrl);
    if (!response.ok)
        return null;
    const jwks = await response.json();
    if (!jwks.keys || !Array.isArray(jwks.keys))
        return null;
    return { url: jwksUrl, jwks };
};
/**
 * Built-in resolver that tries to fetch JWKS from the kid (Key ID) if it looks like a URL.
 * This is a legacy pattern where kid contains a full URL to the JWKS.
 */
export const kidUrlResolver = async (context, validateOrigin) => {
    if (!context.kid)
        return null;
    // Check if kid looks like a URL
    const isUrlLike = context.kid.startsWith('http://') ||
        context.kid.startsWith('https://') ||
        context.kid.includes('.');
    if (!isUrlLike)
        return null;
    validateOrigin(context.kid);
    const response = await fetch(context.kid);
    if (!response.ok)
        return null;
    const jwks = await response.json();
    if (!jwks.keys || !Array.isArray(jwks.keys))
        return null;
    return { url: context.kid, jwks };
};
export class NoWay {
    kvCache;
    keyPrefix;
    defaultTtl;
    originValidator;
    resolvers;
    constructor(options) {
        this.kvCache = options.kvCache;
        this.keyPrefix = options.keyPrefix || 'noway:';
        this.defaultTtl = options.defaultTtl || 3600; // 1 hour default
        this.originValidator = options.originValidator;
        this.resolvers = options.resolvers || [jkuResolver, issuerDiscoveryResolver, kidUrlResolver];
    }
    getCacheKey(key) {
        return `${this.keyPrefix}${key}`;
    }
    generateResolutionCacheKey(context) {
        // Create a cache key based on the full resolution context
        // This allows single cache lookup for the entire resolution process
        const iss = context.iss || '';
        const jku = context.jku || '';
        const kid = context.kid || '';
        return `jwks-resolution:${iss}:${jku}:${kid}`;
    }
    validateOrigin(url) {
        if (!this.originValidator(url)) {
            throw new Error(`JWKS URL origin not allowed: ${url}`);
        }
    }
    async resolveJWKS(context, ttl) {
        const issuerContext = context.iss;
        const cacheTtl = ttl || this.defaultTtl;
        // Single cache lookup based on full resolution context
        const resolutionCacheKey = this.getCacheKey(this.generateResolutionCacheKey(context));
        try {
            const cached = await this.kvCache.get(resolutionCacheKey, 'json');
            if (cached && cached.expiresAt && Date.now() < cached.expiresAt) {
                // Return cached JWKS from previous resolution
                return this.createCachedJWKSGetter(cached, issuerContext);
            }
        }
        catch {
            // If cache read fails, continue to resolve fresh
        }
        // Cache miss - try resolvers in configured order
        let resolvedUrl = null;
        let jwksData = null;
        for (const resolver of this.resolvers) {
            try {
                const result = await resolver(context, this.validateOrigin.bind(this));
                if (result) {
                    resolvedUrl = result.url;
                    jwksData = result.jwks;
                    break; // Successfully resolved, stop trying
                }
            }
            catch (error) {
                // Log origin validation errors but continue to next resolver
                // This allows fallback to other resolution methods even if one has a blocked origin
                if (error instanceof Error && error.message.includes('JWKS URL origin not allowed')) {
                    console.warn(`[NoWay] Resolver blocked: ${error.message}`);
                    continue; // Try next resolver
                }
                // Continue to next resolver for other errors too
            }
        }
        if (!resolvedUrl || !jwksData) {
            throw new Error('Unable to resolve JWKS URL from provided context');
        }
        // Cache the resolved JWKS with resolution metadata
        const cachedJwks = {
            keys: jwksData.keys,
            cachedAt: Date.now(),
            expiresAt: Date.now() + (cacheTtl * 1000),
            source: resolvedUrl,
            keyIds: jwksData.keys.map((key) => key.kid).filter((kid) => Boolean(kid)),
            issuerContext,
            resolvedUrl
        };
        try {
            await this.kvCache.put(resolutionCacheKey, JSON.stringify(cachedJwks), { expirationTtl: cacheTtl });
        }
        catch {
            // If cache write fails, continue without caching
        }
        return this.createCachedJWKSGetter(cachedJwks, issuerContext);
    }
    createCachedJWKSGetter(cached, expectedIssuer) {
        return (protectedHeader, _token) => {
            const targetKid = protectedHeader.kid;
            if (!targetKid) {
                throw new Error('JWT header missing kid claim');
            }
            // Validate issuer context to prevent cross-issuer key usage
            if (expectedIssuer && cached.issuerContext && cached.issuerContext !== expectedIssuer) {
                throw new Error(`JWKS cached for issuer "${cached.issuerContext}" but JWT claims issuer "${expectedIssuer}"`);
            }
            const key = cached.keys.find((k) => k.kid === targetKid);
            if (!key) {
                throw new Error(`Key with kid "${targetKid}" not found in JWKS from source "${cached.source}"`);
            }
            return jose.importJWK(key);
        };
    }
    async verifyJWT(token, secret, options = {}) {
        const joseOptions = {
            algorithms: options.algorithms,
            audience: options.audience,
            issuer: options.issuer,
            clockTolerance: options.clockTolerance,
        };
        if (typeof secret === 'function') {
            // If secret is a JWTVerifyGetKey function (like from JWKS)
            return jose.jwtVerify(token, secret, joseOptions);
        }
        // Convert string secret to Uint8Array for jose, leave others as-is
        let keyForVerification;
        if (typeof secret === 'string') {
            keyForVerification = new TextEncoder().encode(secret);
        }
        else {
            keyForVerification = secret;
        }
        return jose.jwtVerify(token, keyForVerification, joseOptions);
    }
    async verifyJWTWithJWKS(token, options = {}) {
        // Decode the token to extract header and payload
        const header = jose.decodeProtectedHeader(token);
        const payload = jose.decodeJwt(token);
        // Build resolution context from token claims
        const context = {
            header: header,
            payload,
            iss: payload.iss,
            kid: header.kid,
            jku: header.jku
        };
        // Resolve JWKS
        const jwksGetter = await this.resolveJWKS(context, options.jwksTtl);
        // Verify using the resolved JWKS
        return this.verifyJWT(token, jwksGetter, options);
    }
    /**
     * Get a JWTVerifyGetKey function for a token that can be used directly with jose.jwtVerify.
     * This allows users to leverage NoWay's JWKS resolution and caching while maintaining
     * full control over verification options.
     *
     * @param token - The JWT token to get the key getter for
     * @param options - Optional JWKS cache TTL
     * @returns A JWTVerifyGetKey function that can be passed to jose.jwtVerify
     *
     * @example
     * ```typescript
     * const noway = new NoWay({ kvCache, originValidator });
     * const getKey = await noway.getKeyGetter(token);
     *
     * // Use directly with jose
     * const result = await jose.jwtVerify(token, getKey, {
     *   audience: 'my-api',
     *   issuer: 'https://my-issuer.com'
     * });
     * ```
     */
    async getKeyGetter(token, options = {}) {
        // Decode the token to extract header and payload
        const header = jose.decodeProtectedHeader(token);
        const payload = jose.decodeJwt(token);
        // Build resolution context from token claims
        const context = {
            header: header,
            payload,
            iss: payload.iss,
            kid: header.kid,
            jku: header.jku
        };
        // Resolve and return the JWKS getter
        return this.resolveJWKS(context, options.jwksTtl);
    }
    async signJWT(payload, secret, options = {}) {
        const jwt = new jose.SignJWT(payload);
        if (options.issuer)
            jwt.setIssuer(options.issuer);
        if (options.subject)
            jwt.setSubject(options.subject);
        if (options.audience)
            jwt.setAudience(options.audience);
        if (options.expiresIn)
            jwt.setExpirationTime(options.expiresIn);
        if (options.notBefore)
            jwt.setNotBefore(options.notBefore);
        if (options.jti)
            jwt.setJti(options.jti);
        if (!options.noTimestamp)
            jwt.setIssuedAt();
        // Convert string secret to Uint8Array for jose
        let keyForSigning;
        if (typeof secret === 'string') {
            keyForSigning = new TextEncoder().encode(secret);
        }
        else {
            keyForSigning = secret;
        }
        return jwt
            .setProtectedHeader({
            alg: options.algorithm || 'HS256',
            ...options.header
        })
            .sign(keyForSigning);
    }
    async invalidateCache(key) {
        const cacheKey = this.getCacheKey(key);
        try {
            await this.kvCache.delete(cacheKey);
        }
        catch {
            // If cache delete fails, continue silently
        }
    }
    async clearCache() {
        try {
            const result = await this.kvCache.list({ prefix: this.keyPrefix });
            for (const key of result.keys) {
                await this.kvCache.delete(key.name);
            }
        }
        catch {
            // If cache clear fails, continue silently
        }
    }
}
// Re-export commonly used jose types and functions for convenience
export { decodeJwt, decodeProtectedHeader, errors } from 'jose';
export default NoWay;
