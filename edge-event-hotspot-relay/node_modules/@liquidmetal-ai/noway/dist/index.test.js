/* eslint-disable @typescript-eslint/no-explicit-any */
import { beforeEach, describe, expect, it, vi } from 'vitest';
import { NoWay, originList, jkuResolver, issuerDiscoveryResolver } from './index.js';
// Mock KvCache implementation for testing
class MockKvCache {
    store = new Map();
    async get(key, _type) {
        const entry = this.store.get(key);
        if (!entry)
            return null;
        if (entry.expiration && Date.now() > entry.expiration) {
            this.store.delete(key);
            return null;
        }
        return JSON.parse(entry.value);
    }
    async list(options) {
        const keys = Array.from(this.store.keys())
            .filter(key => !options?.prefix || key.startsWith(options.prefix))
            .map(key => ({ name: key }));
        return { keys };
    }
    async put(key, value, options) {
        const expiration = options?.expirationTtl ? Date.now() + (options.expirationTtl * 1000) : undefined;
        this.store.set(key, { value, expiration });
    }
    async delete(key) {
        this.store.delete(key);
    }
}
describe('originList', () => {
    it('should allow URLs from hostnames in the list', () => {
        const validator = originList(['auth0.com', 'googleapis.com', 'okta.com']);
        expect(validator('https://auth0.com/jwks')).toBe(true);
        expect(validator('https://googleapis.com/oauth2/v3/certs')).toBe(true);
        expect(validator('https://okta.com/.well-known/jwks.json')).toBe(true);
    });
    it('should block URLs from hostnames not in the list', () => {
        const validator = originList(['auth0.com', 'googleapis.com']);
        expect(validator('https://evil.com/jwks')).toBe(false);
        expect(validator('https://untrusted.org/keys')).toBe(false);
    });
    it('should handle URLs with ports', () => {
        const validator = originList(['localhost', 'example.com']);
        expect(validator('https://localhost:3000/jwks')).toBe(true);
        expect(validator('http://example.com:8080/keys')).toBe(true);
    });
    it('should handle URLs with paths, query strings, and fragments', () => {
        const validator = originList(['auth0.com']);
        expect(validator('https://auth0.com/path/to/jwks')).toBe(true);
        expect(validator('https://auth0.com/jwks?param=value')).toBe(true);
        expect(validator('https://auth0.com/jwks#fragment')).toBe(true);
        expect(validator('https://auth0.com/path?query=1#frag')).toBe(true);
    });
    it('should not match subdomains unless explicitly listed', () => {
        const validator = originList(['example.com']);
        expect(validator('https://example.com/jwks')).toBe(true);
        expect(validator('https://sub.example.com/jwks')).toBe(false);
        expect(validator('https://api.example.com/jwks')).toBe(false);
    });
    it('should handle malformed URLs gracefully', () => {
        const validator = originList(['auth0.com']);
        expect(validator('not-a-url')).toBe(false);
        expect(validator('htp://malformed')).toBe(false);
        expect(validator('')).toBe(false);
        expect(validator('://missing-protocol')).toBe(false);
    });
    it('should work with empty array (blocks everything)', () => {
        const validator = originList([]);
        expect(validator('https://auth0.com/jwks')).toBe(false);
        expect(validator('https://any-domain.com')).toBe(false);
    });
    it('should be case-sensitive for hostnames', () => {
        const validator = originList(['example.com']);
        // URLs normalize hostnames to lowercase
        expect(validator('https://EXAMPLE.COM/jwks')).toBe(true);
        expect(validator('https://Example.Com/jwks')).toBe(true);
    });
    it('should integrate with NoWay constructor', () => {
        const mockKvCache = new MockKvCache();
        expect(() => {
            new NoWay({
                kvCache: mockKvCache,
                originValidator: originList(['auth0.com', 'okta.com'])
            });
        }).not.toThrow();
    });
    it('should work in realistic NoWay usage scenario', async () => {
        const mockKvCache = new MockKvCache();
        const noway = new NoWay({
            kvCache: mockKvCache,
            originValidator: originList(['trusted.com'])
        });
        // Should fail to resolve when all origins are untrusted
        await expect(noway.resolveJWKS({
            iss: 'https://evil.com',
            kid: 'test-key'
        })).rejects.toThrow('Unable to resolve JWKS URL from provided context');
    });
});
describe('Resolver configuration', () => {
    let mockKvCache;
    beforeEach(() => {
        mockKvCache = new MockKvCache();
        // Mock successful JWKS responses
        global.fetch = vi.fn().mockResolvedValue({
            ok: true,
            json: () => Promise.resolve({
                keys: [{ kty: 'RSA', use: 'sig', kid: 'test-key', n: 'test-n', e: 'AQAB' }]
            })
        });
    });
    it('should use default resolvers (jku, iss, kid) when not specified', async () => {
        const noway = new NoWay({
            kvCache: mockKvCache,
            originValidator: () => true
        });
        const context = {
            jku: 'https://example.com/jwks',
            iss: 'https://example.com',
            kid: 'test-key'
        };
        const jwks = await noway.resolveJWKS(context);
        expect(jwks).toBeDefined();
        // Should have tried jku first (which succeeds)
        expect(global.fetch).toHaveBeenCalledWith('https://example.com/jwks');
    });
    it('should use custom resolver order', async () => {
        const noway = new NoWay({
            kvCache: mockKvCache,
            originValidator: () => true,
            resolvers: [issuerDiscoveryResolver, jkuResolver] // iss first
        });
        global.fetch.mockImplementation((url) => {
            if (url.includes('.well-known/openid-configuration')) {
                return Promise.resolve({
                    ok: true,
                    json: () => Promise.resolve({ jwks_uri: 'https://example.com/jwks' })
                });
            }
            return Promise.resolve({
                ok: true,
                json: () => Promise.resolve({
                    keys: [{ kty: 'RSA', use: 'sig', kid: 'test-key', n: 'test-n', e: 'AQAB' }]
                })
            });
        });
        const context = {
            jku: 'https://example.com/jku-jwks',
            iss: 'https://example.com',
            kid: 'test-key'
        };
        await noway.resolveJWKS(context);
        // Should have tried iss discovery first
        expect(global.fetch).toHaveBeenCalledWith('https://example.com/.well-known/openid-configuration');
    });
    it('should support custom resolver functions', async () => {
        const customResolver = async (context) => {
            if (context.payload?.customField) {
                return {
                    url: 'https://custom.com/jwks',
                    jwks: {
                        keys: [{ kty: 'RSA', use: 'sig', kid: 'custom-key', n: 'test-n', e: 'AQAB' }]
                    }
                };
            }
            return null;
        };
        const noway = new NoWay({
            kvCache: mockKvCache,
            originValidator: () => true,
            resolvers: [customResolver, jkuResolver]
        });
        const context = {
            payload: { customField: 'value' },
            jku: 'https://example.com/jwks',
            kid: 'test-key'
        };
        const jwks = await noway.resolveJWKS(context);
        expect(jwks).toBeDefined();
        // Custom resolver should have been used
        // We can verify by checking that jku fetch wasn't called
        expect(global.fetch).not.toHaveBeenCalledWith('https://example.com/jwks');
    });
    it('should try resolvers in order until one succeeds', async () => {
        let resolverCallCount = 0;
        const failingResolver1 = async () => {
            resolverCallCount++;
            return null; // Fails
        };
        const failingResolver2 = async () => {
            resolverCallCount++;
            return null; // Fails
        };
        const successfulResolver = async () => {
            resolverCallCount++;
            return {
                url: 'https://success.com/jwks',
                jwks: {
                    keys: [{ kty: 'RSA', use: 'sig', kid: 'test-key', n: 'test-n', e: 'AQAB' }]
                }
            };
        };
        const noway = new NoWay({
            kvCache: mockKvCache,
            originValidator: () => true,
            resolvers: [failingResolver1, failingResolver2, successfulResolver]
        });
        const context = { kid: 'test-key' };
        const jwks = await noway.resolveJWKS(context);
        expect(jwks).toBeDefined();
        expect(resolverCallCount).toBe(3); // All three were tried in order
    });
    it('should stop trying resolvers after first success', async () => {
        let resolverCallCount = 0;
        const successfulResolver = async () => {
            resolverCallCount++;
            return {
                url: 'https://success.com/jwks',
                jwks: {
                    keys: [{ kty: 'RSA', use: 'sig', kid: 'test-key', n: 'test-n', e: 'AQAB' }]
                }
            };
        };
        const shouldNotBeCalled = async () => {
            resolverCallCount++;
            throw new Error('This resolver should not be called');
        };
        const noway = new NoWay({
            kvCache: mockKvCache,
            originValidator: () => true,
            resolvers: [successfulResolver, shouldNotBeCalled]
        });
        const context = { kid: 'test-key' };
        const jwks = await noway.resolveJWKS(context);
        expect(jwks).toBeDefined();
        expect(resolverCallCount).toBe(1); // Only first resolver called
    });
    it('should continue to next resolver when origin validation fails', async () => {
        const badOriginResolver = async (_context, validateOrigin) => {
            validateOrigin('https://evil.com/jwks'); // This throws but shouldn't stop chain
            return null;
        };
        const goodResolver = async () => {
            return {
                url: 'https://good.com/jwks',
                jwks: {
                    keys: [{ kty: 'RSA', use: 'sig', kid: 'test-key', n: 'test-n', e: 'AQAB' }]
                }
            };
        };
        const noway = new NoWay({
            kvCache: mockKvCache,
            originValidator: (url) => url === 'https://good.com/jwks', // Only allow good.com
            resolvers: [badOriginResolver, goodResolver]
        });
        const context = { kid: 'test-key' };
        // Should succeed using the second resolver
        const jwks = await noway.resolveJWKS(context);
        expect(jwks).toBeDefined();
    });
    it('should log warning when origin validation fails', async () => {
        const consoleWarnSpy = vi.spyOn(console, 'warn').mockImplementation(() => { });
        const badOriginResolver = async (_context, validateOrigin) => {
            validateOrigin('https://evil.com/jwks');
            return null;
        };
        const goodResolver = async () => {
            return {
                url: 'https://good.com/jwks',
                jwks: {
                    keys: [{ kty: 'RSA', use: 'sig', kid: 'test-key', n: 'test-n', e: 'AQAB' }]
                }
            };
        };
        const noway = new NoWay({
            kvCache: mockKvCache,
            originValidator: () => false, // Block all origins
            resolvers: [badOriginResolver, goodResolver]
        });
        const context = { kid: 'test-key' };
        await noway.resolveJWKS(context);
        // Should have logged the blocked origin
        expect(consoleWarnSpy).toHaveBeenCalledWith(expect.stringContaining('[NoWay] Resolver blocked: JWKS URL origin not allowed: https://evil.com/jwks'));
        consoleWarnSpy.mockRestore();
    });
    it('should throw error if no resolver succeeds', async () => {
        const failingResolver1 = async () => null;
        const failingResolver2 = async () => null;
        const noway = new NoWay({
            kvCache: mockKvCache,
            originValidator: () => true,
            resolvers: [failingResolver1, failingResolver2]
        });
        const context = { kid: 'test-key' };
        await expect(noway.resolveJWKS(context)).rejects.toThrow('Unable to resolve JWKS URL from provided context');
    });
    it('should skip resolvers for other errors and try next resolver', async () => {
        let secondResolverCalled = false;
        const throwingResolver = async () => {
            throw new Error('Network error'); // Non-origin-validation error
        };
        const successfulResolver = async () => {
            secondResolverCalled = true;
            return {
                url: 'https://success.com/jwks',
                jwks: {
                    keys: [{ kty: 'RSA', use: 'sig', kid: 'test-key', n: 'test-n', e: 'AQAB' }]
                }
            };
        };
        const noway = new NoWay({
            kvCache: mockKvCache,
            originValidator: () => true,
            resolvers: [throwingResolver, successfulResolver]
        });
        const context = { kid: 'test-key' };
        const jwks = await noway.resolveJWKS(context);
        expect(jwks).toBeDefined();
        expect(secondResolverCalled).toBe(true);
    });
    it('should work with single resolver', async () => {
        const noway = new NoWay({
            kvCache: mockKvCache,
            originValidator: () => true,
            resolvers: [jkuResolver] // Only jku
        });
        const context = {
            jku: 'https://example.com/jwks',
            kid: 'test-key'
        };
        const jwks = await noway.resolveJWKS(context);
        expect(jwks).toBeDefined();
    });
    it('should work with empty resolvers array and throw error', async () => {
        const noway = new NoWay({
            kvCache: mockKvCache,
            originValidator: () => true,
            resolvers: [] // No resolvers
        });
        const context = { kid: 'test-key' };
        await expect(noway.resolveJWKS(context)).rejects.toThrow('Unable to resolve JWKS URL from provided context');
    });
});
describe('NoWay', () => {
    let mockKvCache;
    let noWay;
    beforeEach(() => {
        mockKvCache = new MockKvCache();
        const options = {
            kvCache: mockKvCache,
            keyPrefix: 'test:',
            defaultTtl: 3600,
            originValidator: () => true // Allow all origins for general tests
        };
        noWay = new NoWay(options);
    });
    describe('constructor', () => {
        it('should initialize with default values', () => {
            const defaultNoWay = new NoWay({
                kvCache: mockKvCache,
                originValidator: () => true
            });
            expect(defaultNoWay).toBeInstanceOf(NoWay);
        });
        it('should initialize with custom options', () => {
            expect(noWay).toBeInstanceOf(NoWay);
        });
        it('should require originValidator to be provided', async () => {
            // TypeScript prevents this, but test runtime behavior
            expect(() => {
                new NoWay({
                    kvCache: mockKvCache
                });
            }).not.toThrow(); // Constructor doesn't validate, TypeScript does
            // The important test: originValidator is actually used
            const noWayWithValidator = new NoWay({
                kvCache: mockKvCache,
                originValidator: () => false // Block everything
            });
            await expect(noWayWithValidator.resolveJWKS({
                iss: 'https://example.com',
                kid: 'test-key'
            })).rejects.toThrow('Unable to resolve JWKS URL from provided context');
        });
    });
    describe('signJWT', () => {
        const secret = 'test-secret';
        const payload = { sub: '1234567890', name: 'John Doe', iat: 1516239022 };
        it('should sign a JWT', async () => {
            const token = await noWay.signJWT(payload, secret);
            expect(typeof token).toBe('string');
            expect(token.split('.')).toHaveLength(3);
        });
        it('should sign with custom options', async () => {
            const options = {
                issuer: 'test-issuer',
                audience: 'test-audience',
                expiresIn: '1h',
                subject: 'test-subject'
            };
            const token = await noWay.signJWT(payload, secret, options);
            expect(typeof token).toBe('string');
        });
    });
    describe('verifyJWT', () => {
        const secret = 'test-secret';
        const payload = { sub: '1234567890', name: 'John Doe' };
        it('should verify a JWT', async () => {
            const token = await noWay.signJWT(payload, secret);
            const result = await noWay.verifyJWT(token, secret);
            expect(result.payload.sub).toBe(payload.sub);
            expect(result.payload.name).toBe(payload.name);
        });
        it('should verify with custom options', async () => {
            const signOptions = {
                issuer: 'test-issuer',
                audience: 'test-audience'
            };
            const token = await noWay.signJWT(payload, secret, signOptions);
            const verifyOptions = {
                issuer: 'test-issuer',
                audience: 'test-audience'
            };
            const result = await noWay.verifyJWT(token, secret, verifyOptions);
            expect(result.payload.sub).toBe(payload.sub);
        });
        it('should throw error for invalid JWT', async () => {
            const invalidToken = 'invalid.jwt.token';
            await expect(noWay.verifyJWT(invalidToken, secret))
                .rejects.toThrow();
        });
    });
    describe('JWKS caching and resolution', () => {
        const testJwks = {
            keys: [
                {
                    kty: 'RSA',
                    use: 'sig',
                    kid: 'test-key-1',
                    n: 'test-n-value',
                    e: 'AQAB'
                },
                {
                    kty: 'RSA',
                    use: 'sig',
                    kid: 'test-key-2',
                    n: 'another-n-value',
                    e: 'AQAB'
                }
            ]
        };
        beforeEach(() => {
            // Mock fetch for JWKS endpoint
            global.fetch = vi.fn().mockResolvedValue({
                ok: true,
                json: () => Promise.resolve(testJwks)
            });
        });
        describe('resolveJWKS', () => {
            beforeEach(() => {
                // Mock OpenID Connect discovery
                global.fetch.mockImplementation((url) => {
                    if (url.includes('.well-known/openid-configuration')) {
                        return Promise.resolve({
                            ok: true,
                            json: () => Promise.resolve({
                                jwks_uri: 'https://issuer.example.com/jwks'
                            })
                        });
                    }
                    // Default JWKS response
                    return Promise.resolve({
                        ok: true,
                        json: () => Promise.resolve(testJwks)
                    });
                });
            });
            it('should resolve JWKS from jku claim first', async () => {
                const context = {
                    header: { alg: 'RS256', kid: 'test-key-1', jku: 'https://jku.example.com/jwks' },
                    payload: { iss: 'https://issuer.example.com' },
                    jku: 'https://jku.example.com/jwks',
                    iss: 'https://issuer.example.com',
                    kid: 'test-key-1'
                };
                const jwks = await noWay.resolveJWKS(context);
                expect(typeof jwks).toBe('function');
                // Should cache with resolution context key
                const cacheKey = 'test:jwks-resolution:https://issuer.example.com:https://jku.example.com/jwks:test-key-1';
                const cached = await mockKvCache.get(cacheKey, 'json');
                expect(cached).toBeTruthy();
            });
            it('should fall back to issuer discovery when jku fails', async () => {
                global.fetch.mockImplementation((url) => {
                    if (url.includes('jku.example.com')) {
                        return Promise.resolve({ ok: false, status: 404 });
                    }
                    if (url.includes('.well-known/openid-configuration')) {
                        return Promise.resolve({
                            ok: true,
                            json: () => Promise.resolve({
                                jwks_uri: 'https://issuer.example.com/jwks'
                            })
                        });
                    }
                    return Promise.resolve({
                        ok: true,
                        json: () => Promise.resolve(testJwks)
                    });
                });
                const context = {
                    header: { alg: 'RS256', kid: 'test-key-1', jku: 'https://jku.example.com/jwks' },
                    payload: { iss: 'https://issuer.example.com' },
                    jku: 'https://jku.example.com/jwks',
                    iss: 'https://issuer.example.com',
                    kid: 'test-key-1'
                };
                const jwks = await noWay.resolveJWKS(context);
                expect(typeof jwks).toBe('function');
                // Should cache with resolution context key
                const cacheKey = 'test:jwks-resolution:https://issuer.example.com:https://jku.example.com/jwks:test-key-1';
                const cached = await mockKvCache.get(cacheKey, 'json');
                expect(cached).toBeTruthy();
            });
            it('should fall back to kid URL when other methods fail', async () => {
                global.fetch.mockImplementation((url) => {
                    if (url.includes('jku.example.com') || url.includes('.well-known/openid-configuration')) {
                        return Promise.resolve({ ok: false, status: 404 });
                    }
                    if (url.includes('kid.example.com')) {
                        return Promise.resolve({
                            ok: true,
                            json: () => Promise.resolve(testJwks)
                        });
                    }
                    return Promise.resolve({ ok: false, status: 404 });
                });
                const context = {
                    header: { alg: 'RS256', kid: 'https://kid.example.com/jwks' },
                    payload: { iss: 'https://issuer.example.com' },
                    jku: 'https://jku.example.com/jwks',
                    iss: 'https://issuer.example.com',
                    kid: 'https://kid.example.com/jwks'
                };
                const jwks = await noWay.resolveJWKS(context);
                expect(typeof jwks).toBe('function');
                // Should cache with resolution context key
                const cacheKey = 'test:jwks-resolution:https://issuer.example.com:https://jku.example.com/jwks:https://kid.example.com/jwks';
                const cached = await mockKvCache.get(cacheKey, 'json');
                expect(cached).toBeTruthy();
            });
            it('should throw error when no JWKS URL can be resolved', async () => {
                global.fetch.mockResolvedValue({ ok: false, status: 404 });
                const context = {
                    header: { alg: 'RS256', kid: 'plain-key-id' },
                    payload: { iss: 'https://issuer.example.com' },
                    iss: 'https://issuer.example.com',
                    kid: 'plain-key-id'
                };
                await expect(noWay.resolveJWKS(context)).rejects.toThrow('Unable to resolve JWKS URL');
            });
        });
        describe('verifyJWTWithJWKS', () => {
            let testToken;
            beforeEach(async () => {
                // Create a test token with the required claims
                const payload = {
                    iss: 'https://issuer.example.com',
                    sub: 'test-user',
                    aud: 'test-audience'
                };
                const secret = 'test-secret';
                testToken = await noWay.signJWT(payload, secret, {
                    header: { alg: 'HS256', kid: 'test-key-1' }
                });
                // Mock successful JWKS resolution
                global.fetch.mockImplementation((url) => {
                    if (url.includes('.well-known/openid-configuration')) {
                        return Promise.resolve({
                            ok: true,
                            json: () => Promise.resolve({
                                jwks_uri: 'https://issuer.example.com/jwks'
                            })
                        });
                    }
                    return Promise.resolve({
                        ok: true,
                        json: () => Promise.resolve(testJwks)
                    });
                });
            });
            it('should automatically resolve and verify JWT using JWKS', async () => {
                // Since we're using HMAC for testing but the resolver expects RSA keys,
                // we'll test the method structure rather than end-to-end verification
                expect(async () => {
                    await noWay.verifyJWTWithJWKS(testToken);
                }).toBeDefined();
            });
            it('should use jwksTtl option for JWKS caching', async () => {
                const options = { jwksTtl: 7200 };
                try {
                    await noWay.verifyJWTWithJWKS(testToken, options);
                }
                catch {
                    // Expected to fail due to key type mismatch, but JWKS should be cached
                }
                // Check if JWKS was cached with custom TTL using resolution context key
                const cacheKey = 'test:jwks-resolution:https://issuer.example.com::test-key-1';
                const cached = await mockKvCache.get(cacheKey, 'json');
                expect(cached).toBeTruthy();
                expect(cached.expiresAt).toBeGreaterThan(Date.now() + 7000 * 1000); // Should be ~7200s from now
            });
        });
        describe('getKeyGetter', () => {
            let testToken;
            beforeEach(async () => {
                // Create a test token with the required claims
                const payload = {
                    iss: 'https://issuer.example.com',
                    sub: 'test-user',
                    aud: 'test-audience'
                };
                const secret = 'test-secret';
                testToken = await noWay.signJWT(payload, secret, {
                    header: { alg: 'HS256', kid: 'test-key-1' }
                });
                // Mock successful JWKS resolution
                global.fetch.mockImplementation((url) => {
                    if (url.includes('.well-known/openid-configuration')) {
                        return Promise.resolve({
                            ok: true,
                            json: () => Promise.resolve({
                                jwks_uri: 'https://issuer.example.com/jwks'
                            })
                        });
                    }
                    return Promise.resolve({
                        ok: true,
                        json: () => Promise.resolve(testJwks)
                    });
                });
            });
            it('should return a JWTVerifyGetKey function', async () => {
                const getKey = await noWay.getKeyGetter(testToken);
                expect(getKey).toBeDefined();
                expect(typeof getKey).toBe('function');
            });
            it('should cache JWKS when getting key getter', async () => {
                await noWay.getKeyGetter(testToken);
                // Check if JWKS was cached using resolution context key
                const cacheKey = 'test:jwks-resolution:https://issuer.example.com::test-key-1';
                const cached = await mockKvCache.get(cacheKey, 'json');
                expect(cached).toBeTruthy();
            });
            it('should use custom jwksTtl for caching', async () => {
                const options = { jwksTtl: 7200 };
                await noWay.getKeyGetter(testToken, options);
                // Check if JWKS was cached with custom TTL
                const cacheKey = 'test:jwks-resolution:https://issuer.example.com::test-key-1';
                const cached = await mockKvCache.get(cacheKey, 'json');
                expect(cached).toBeTruthy();
                expect(cached.expiresAt).toBeGreaterThan(Date.now() + 7000 * 1000); // Should be ~7200s from now
            });
            it('should work with jose.jwtVerify', async () => {
                // This test verifies the pattern works conceptually
                // In practice, the key types won't match (HMAC vs RSA)
                const getKey = await noWay.getKeyGetter(testToken);
                // Verify the function signature matches jose.JWTVerifyGetKey
                expect(typeof getKey).toBe('function');
                // The function should accept jose parameters
                // We can't fully test end-to-end due to key type mismatch
                // but we can verify it's the right type of function
                const result = getKey({ kid: 'test-key-1', alg: 'RS256' }, { payload: 'test', protected: 'header', signature: 'sig' });
                expect(result).toBeInstanceOf(Promise);
            });
        });
        describe('JWKS key lookup', () => {
            beforeEach(() => {
                global.fetch.mockImplementation((url) => {
                    if (url.includes('.well-known/openid-configuration')) {
                        return Promise.resolve({
                            ok: true,
                            json: () => Promise.resolve({
                                jwks_uri: 'https://example.com/.well-known/jwks.json'
                            })
                        });
                    }
                    return Promise.resolve({
                        ok: true,
                        json: () => Promise.resolve(testJwks)
                    });
                });
            });
            it('should find correct key by kid', async () => {
                const context = {
                    iss: 'https://example.com',
                    kid: 'test-key-1'
                };
                const jwksGetter = await noWay.resolveJWKS(context);
                // Should work with valid kid
                expect(jwksGetter).toBeDefined();
                // Test that it returns a promise when called with valid kid
                const promise = jwksGetter({ kid: 'test-key-1', alg: 'RS256' }, { payload: 'test', protected: 'header', signature: 'sig' });
                expect(promise).toBeInstanceOf(Promise);
            });
            it('should throw error for missing kid in header', async () => {
                const context = {
                    iss: 'https://example.com',
                    kid: 'test-key-1'
                };
                const jwksGetter = await noWay.resolveJWKS(context);
                expect(() => jwksGetter({ alg: 'RS256' }, { payload: 'test', protected: 'header', signature: 'sig' })).toThrow('JWT header missing kid claim');
            });
            it('should throw error for unknown kid', async () => {
                const context = {
                    iss: 'https://example.com',
                    kid: 'test-key-1'
                };
                const jwksGetter = await noWay.resolveJWKS(context);
                expect(() => jwksGetter({ kid: 'unknown-key', alg: 'RS256' }, { payload: 'test', protected: 'header', signature: 'sig' })).toThrow('Key with kid "unknown-key" not found in JWKS');
            });
        });
        describe('cache collision prevention', () => {
            const auth0Jwks = {
                keys: [
                    {
                        kty: 'RSA',
                        use: 'sig',
                        kid: 'shared-key-1',
                        n: 'auth0-n-value',
                        e: 'AQAB'
                    }
                ]
            };
            const googleJwks = {
                keys: [
                    {
                        kty: 'RSA',
                        use: 'sig',
                        kid: 'shared-key-1', // Same kid as Auth0!
                        n: 'google-n-value',
                        e: 'AQAB'
                    }
                ]
            };
            beforeEach(() => {
                // Mock different responses for different issuers
                global.fetch.mockImplementation((url) => {
                    if (url.includes('auth0.com')) {
                        if (url.includes('.well-known/openid-configuration')) {
                            return Promise.resolve({
                                ok: true,
                                json: () => Promise.resolve({
                                    jwks_uri: 'https://auth0.com/jwks'
                                })
                            });
                        }
                        return Promise.resolve({
                            ok: true,
                            json: () => Promise.resolve(auth0Jwks)
                        });
                    }
                    if (url.includes('google.com')) {
                        if (url.includes('.well-known/openid-configuration')) {
                            return Promise.resolve({
                                ok: true,
                                json: () => Promise.resolve({
                                    jwks_uri: 'https://google.com/jwks'
                                })
                            });
                        }
                        return Promise.resolve({
                            ok: true,
                            json: () => Promise.resolve(googleJwks)
                        });
                    }
                    return Promise.resolve({ ok: false, status: 404 });
                });
            });
            it('should cache JWKS separately for different issuers using same kid', async () => {
                const auth0Context = {
                    header: { alg: 'RS256', kid: 'shared-key-1' },
                    payload: { iss: 'https://auth0.com' },
                    iss: 'https://auth0.com',
                    kid: 'shared-key-1'
                };
                const googleContext = {
                    header: { alg: 'RS256', kid: 'shared-key-1' },
                    payload: { iss: 'https://google.com' },
                    iss: 'https://google.com',
                    kid: 'shared-key-1'
                };
                // Resolve JWKS for both issuers
                const auth0Jwks = await noWay.resolveJWKS(auth0Context);
                const googleJwks = await noWay.resolveJWKS(googleContext);
                // Both should succeed and be different instances
                expect(auth0Jwks).toBeDefined();
                expect(googleJwks).toBeDefined();
                expect(auth0Jwks).not.toBe(googleJwks);
                // Verify separate cache entries exist using resolution context keys
                const auth0CacheKey = 'test:jwks-resolution:https://auth0.com::shared-key-1';
                const googleCacheKey = 'test:jwks-resolution:https://google.com::shared-key-1';
                const auth0Cached = await mockKvCache.get(auth0CacheKey, 'json');
                const googleCached = await mockKvCache.get(googleCacheKey, 'json');
                expect(auth0Cached).toBeTruthy();
                expect(googleCached).toBeTruthy();
                expect(auth0Cached.issuerContext).toBe('https://auth0.com');
                expect(googleCached.issuerContext).toBe('https://google.com');
                // Verify keys are different (different 'n' values)
                expect(auth0Cached.keys[0].n).toBe('auth0-n-value');
                expect(googleCached.keys[0].n).toBe('google-n-value');
            });
            it('should prevent cross-issuer key usage', async () => {
                // First, cache JWKS for Auth0
                const auth0Context = {
                    header: { alg: 'RS256', kid: 'shared-key-1' },
                    payload: { iss: 'https://auth0.com' },
                    iss: 'https://auth0.com',
                    kid: 'shared-key-1'
                };
                await noWay.resolveJWKS(auth0Context);
                // Manually get the cached JWKS getter
                const cacheKey = 'test:jwks-resolution:https://auth0.com::shared-key-1';
                const cached = await mockKvCache.get(cacheKey, 'json');
                // Create getter with wrong expected issuer
                const jwksGetter = noWay.createCachedJWKSGetter(cached, 'https://google.com');
                // Should throw error when trying to use Auth0 key for Google token
                expect(() => {
                    jwksGetter({ kid: 'shared-key-1', alg: 'RS256' }, { payload: 'test', protected: 'header', signature: 'sig' });
                }).toThrow('JWKS cached for issuer "https://auth0.com" but JWT claims issuer "https://google.com"');
            });
            it('should handle shared JWKS URLs with different issuer contexts', async () => {
                const sharedJwksUrl = 'https://shared.com/jwks';
                // Mock shared JWKS endpoint
                global.fetch.mockImplementation((url) => {
                    if (url.includes('shared.com/jwks')) {
                        return Promise.resolve({
                            ok: true,
                            json: () => Promise.resolve({
                                keys: [
                                    {
                                        kty: 'RSA',
                                        use: 'sig',
                                        kid: 'shared-key-1',
                                        n: 'shared-n-value',
                                        e: 'AQAB'
                                    }
                                ]
                            })
                        });
                    }
                    return Promise.resolve({ ok: false, status: 404 });
                });
                // Two different issuers using the same JKU URL
                const context1 = {
                    header: { alg: 'RS256', kid: 'shared-key-1', jku: sharedJwksUrl },
                    payload: { iss: 'https://issuer1.com' },
                    iss: 'https://issuer1.com',
                    jku: sharedJwksUrl,
                    kid: 'shared-key-1'
                };
                const context2 = {
                    header: { alg: 'RS256', kid: 'shared-key-1', jku: sharedJwksUrl },
                    payload: { iss: 'https://issuer2.com' },
                    iss: 'https://issuer2.com',
                    jku: sharedJwksUrl,
                    kid: 'shared-key-1'
                };
                // Should create separate cache entries even though same JKU URL
                await noWay.resolveJWKS(context1);
                await noWay.resolveJWKS(context2);
                const cache1Key = 'test:jwks-resolution:https://issuer1.com:https://shared.com/jwks:shared-key-1';
                const cache2Key = 'test:jwks-resolution:https://issuer2.com:https://shared.com/jwks:shared-key-1';
                const cached1 = await mockKvCache.get(cache1Key, 'json');
                const cached2 = await mockKvCache.get(cache2Key, 'json');
                expect(cached1).toBeTruthy();
                expect(cached2).toBeTruthy();
                expect(cached1.issuerContext).toBe('https://issuer1.com');
                expect(cached2.issuerContext).toBe('https://issuer2.com');
            });
        });
        describe('origin validation', () => {
            const allowedOrigins = ['trusted.com', 'auth0.com', 'googleapis.com'];
            const originValidator = (url) => {
                try {
                    const hostname = new URL(url).hostname;
                    return allowedOrigins.includes(hostname);
                }
                catch {
                    return false;
                }
            };
            let restrictedNoWay;
            beforeEach(() => {
                restrictedNoWay = new NoWay({
                    kvCache: mockKvCache,
                    keyPrefix: 'restricted:',
                    originValidator
                });
            });
            describe('JWK Set URL (jku) validation', () => {
                it('should allow trusted jku origins', async () => {
                    global.fetch.mockResolvedValue({
                        ok: true,
                        json: () => Promise.resolve({
                            keys: [{ kty: 'RSA', use: 'sig', kid: 'test-key', n: 'test-n', e: 'AQAB' }]
                        })
                    });
                    const context = {
                        header: { alg: 'RS256', kid: 'test-key', jku: 'https://trusted.com/jwks' },
                        payload: { iss: 'https://trusted.com' },
                        jku: 'https://trusted.com/jwks',
                        iss: 'https://trusted.com',
                        kid: 'test-key'
                    };
                    const jwks = await restrictedNoWay.resolveJWKS(context);
                    expect(jwks).toBeDefined();
                });
                it('should block untrusted jku origins', async () => {
                    const context = {
                        header: { alg: 'RS256', kid: 'test-key', jku: 'https://evil.com/jwks' },
                        payload: { iss: 'https://trusted.com' },
                        jku: 'https://evil.com/jwks',
                        iss: 'https://trusted.com',
                        kid: 'test-key'
                    };
                    // Should fail to resolve since jku is blocked and iss/kid also don't succeed
                    await expect(restrictedNoWay.resolveJWKS(context)).rejects.toThrow('Unable to resolve JWKS URL from provided context');
                });
            });
            describe('issuer discovery validation', () => {
                it('should allow trusted issuer discovery', async () => {
                    global.fetch.mockImplementation((url) => {
                        if (url.includes('.well-known/openid-configuration')) {
                            return Promise.resolve({
                                ok: true,
                                json: () => Promise.resolve({
                                    jwks_uri: 'https://trusted.com/jwks'
                                })
                            });
                        }
                        return Promise.resolve({
                            ok: true,
                            json: () => Promise.resolve({
                                keys: [{ kty: 'RSA', use: 'sig', kid: 'test-key', n: 'test-n', e: 'AQAB' }]
                            })
                        });
                    });
                    const context = {
                        header: { alg: 'RS256', kid: 'test-key' },
                        payload: { iss: 'https://trusted.com' },
                        iss: 'https://trusted.com',
                        kid: 'test-key'
                    };
                    const jwks = await restrictedNoWay.resolveJWKS(context);
                    expect(jwks).toBeDefined();
                });
                it('should block untrusted issuer discovery', async () => {
                    const context = {
                        header: { alg: 'RS256', kid: 'test-key' },
                        payload: { iss: 'https://evil.com' },
                        iss: 'https://evil.com',
                        kid: 'test-key'
                    };
                    // Should fail to resolve since issuer is blocked
                    await expect(restrictedNoWay.resolveJWKS(context)).rejects.toThrow('Unable to resolve JWKS URL from provided context');
                });
                it('should block untrusted discovered JWKS URL even if issuer is trusted', async () => {
                    global.fetch.mockImplementation((url) => {
                        if (url.includes('.well-known/openid-configuration')) {
                            return Promise.resolve({
                                ok: true,
                                json: () => Promise.resolve({
                                    jwks_uri: 'https://evil.com/jwks' // Malicious redirect
                                })
                            });
                        }
                        return Promise.resolve({ ok: false });
                    });
                    const context = {
                        header: { alg: 'RS256', kid: 'test-key' },
                        payload: { iss: 'https://trusted.com' },
                        iss: 'https://trusted.com',
                        kid: 'test-key'
                    };
                    // Should fail to resolve since discovered jwks_uri is blocked
                    await expect(restrictedNoWay.resolveJWKS(context)).rejects.toThrow('Unable to resolve JWKS URL from provided context');
                });
            });
            describe('kid URL validation', () => {
                it('should allow trusted kid URL', async () => {
                    global.fetch.mockImplementation((url) => {
                        if (url.includes('.well-known/openid-configuration')) {
                            return Promise.resolve({ ok: false, status: 404 });
                        }
                        if (url.includes('trusted.com')) {
                            return Promise.resolve({
                                ok: true,
                                json: () => Promise.resolve({
                                    keys: [{ kty: 'RSA', use: 'sig', kid: 'test-key', n: 'test-n', e: 'AQAB' }]
                                })
                            });
                        }
                        return Promise.resolve({ ok: false, status: 404 });
                    });
                    const context = {
                        header: { alg: 'RS256', kid: 'https://trusted.com/key1' },
                        payload: { iss: 'https://trusted.com' },
                        iss: 'https://trusted.com',
                        kid: 'https://trusted.com/key1'
                    };
                    const jwks = await restrictedNoWay.resolveJWKS(context);
                    expect(jwks).toBeDefined();
                });
                it('should block untrusted kid URL', async () => {
                    global.fetch.mockResolvedValue({ ok: false, status: 404 });
                    const context = {
                        header: { alg: 'RS256', kid: 'https://evil.com/steal-data' },
                        payload: { iss: 'https://trusted.com' },
                        iss: 'https://trusted.com',
                        kid: 'https://evil.com/steal-data'
                    };
                    // Should fail to resolve since kid URL is blocked
                    await expect(restrictedNoWay.resolveJWKS(context)).rejects.toThrow('Unable to resolve JWKS URL from provided context');
                });
            });
            describe('edge cases', () => {
                it('should handle malformed URLs gracefully with jku', async () => {
                    const malformedValidator = (url) => {
                        try {
                            new URL(url);
                            return true;
                        }
                        catch {
                            return false;
                        }
                    };
                    const edgeCaseNoWay = new NoWay({
                        kvCache: mockKvCache,
                        originValidator: malformedValidator
                    });
                    // Should fail to resolve since jku is malformed and blocked
                    await expect(edgeCaseNoWay.resolveJWKS({
                        iss: 'https://example.com',
                        kid: 'test-key',
                        jku: 'not-a-url'
                    })).rejects.toThrow('Unable to resolve JWKS URL from provided context');
                });
                it('should support non-URL issuer with kid as URL', async () => {
                    // Mock JWKS response for kid URL
                    global.fetch.mockResolvedValue({
                        ok: true,
                        json: () => Promise.resolve({
                            keys: [{
                                    kty: 'RSA',
                                    use: 'sig',
                                    kid: 'rainbow-key-1',
                                    n: 'test-n-value',
                                    e: 'AQAB'
                                }]
                        })
                    });
                    const context = {
                        iss: 'production.rainbow-service', // Not a URL!
                        kid: 'https://keys.rainbow.com/jwks#prod' // URL with fragment
                    };
                    const jwksGetter = await noWay.resolveJWKS(context);
                    expect(jwksGetter).toBeDefined();
                    // Should have fetched from the kid URL
                    expect(global.fetch).toHaveBeenCalledWith('https://keys.rainbow.com/jwks#prod');
                });
            });
        });
    });
    describe('cache management', () => {
        beforeEach(() => {
            // Mock fetch for JWKS endpoint with OpenID Connect discovery
            global.fetch.mockImplementation((url) => {
                if (url.includes('.well-known/openid-configuration')) {
                    return Promise.resolve({
                        ok: true,
                        json: () => Promise.resolve({
                            jwks_uri: 'https://example.com/jwks'
                        })
                    });
                }
                return Promise.resolve({
                    ok: true,
                    json: () => Promise.resolve({
                        keys: [{ kty: 'RSA', use: 'sig', kid: 'test-key', n: 'test-n', e: 'AQAB' }]
                    })
                });
            });
        });
        it('should invalidate specific JWKS cache entry', async () => {
            // Cache JWKS by resolving
            const context = {
                iss: 'https://example.com',
                kid: 'test-key'
            };
            await noWay.resolveJWKS(context);
            // Verify it's cached
            const cacheKey = 'test:jwks-resolution:https://example.com::test-key';
            let cached = await mockKvCache.get(cacheKey, 'json');
            expect(cached).toBeTruthy();
            // Invalidate cache
            await noWay.invalidateCache('jwks-resolution:https://example.com::test-key');
            // Verify it's gone
            cached = await mockKvCache.get(cacheKey, 'json');
            expect(cached).toBeNull();
        });
        it('should clear all cache entries', async () => {
            // Cache multiple JWKS entries
            const context1 = {
                iss: 'https://example1.com',
                kid: 'test-key-1'
            };
            const context2 = {
                iss: 'https://example2.com',
                kid: 'test-key-2'
            };
            await noWay.resolveJWKS(context1);
            await noWay.resolveJWKS(context2);
            // Verify they're cached
            let cached1 = await mockKvCache.get('test:jwks-resolution:https://example1.com::test-key-1', 'json');
            let cached2 = await mockKvCache.get('test:jwks-resolution:https://example2.com::test-key-2', 'json');
            expect(cached1).toBeTruthy();
            expect(cached2).toBeTruthy();
            // Clear all cache
            await noWay.clearCache();
            // Verify they're gone
            cached1 = await mockKvCache.get('test:jwks-resolution:https://example1.com::test-key-1', 'json');
            cached2 = await mockKvCache.get('test:jwks-resolution:https://example2.com::test-key-2', 'json');
            expect(cached1).toBeNull();
            expect(cached2).toBeNull();
        });
    });
    describe('error handling', () => {
        beforeEach(() => {
            // Mock fetch for JWKS endpoint with OpenID Connect discovery
            global.fetch.mockImplementation((url) => {
                if (url.includes('.well-known/openid-configuration')) {
                    return Promise.resolve({
                        ok: true,
                        json: () => Promise.resolve({
                            jwks_uri: 'https://example.com/jwks'
                        })
                    });
                }
                return Promise.resolve({
                    ok: true,
                    json: () => Promise.resolve({
                        keys: [{ kty: 'RSA', use: 'sig', kid: 'test-key', n: 'test-n', e: 'AQAB' }]
                    })
                });
            });
        });
        it('should handle cache read errors gracefully during JWKS resolution', async () => {
            const faultyCache = {
                get: vi.fn().mockRejectedValue(new Error('Cache read error')),
                put: vi.fn().mockResolvedValue(undefined),
                delete: vi.fn().mockResolvedValue(undefined),
                list: vi.fn().mockResolvedValue({ keys: [] })
            };
            const faultyNoWay = new NoWay({
                kvCache: faultyCache,
                originValidator: () => true
            });
            // Should not throw, should continue without cache read
            const context = { iss: 'https://example.com', kid: 'test-key' };
            const jwksGetter = await faultyNoWay.resolveJWKS(context);
            expect(jwksGetter).toBeDefined();
            expect(typeof jwksGetter).toBe('function');
        });
        it('should handle cache write errors gracefully during JWKS resolution', async () => {
            const faultyCache = {
                get: vi.fn().mockResolvedValue(null),
                put: vi.fn().mockRejectedValue(new Error('Cache write error')),
                delete: vi.fn().mockResolvedValue(undefined),
                list: vi.fn().mockResolvedValue({ keys: [] })
            };
            const faultyNoWay = new NoWay({
                kvCache: faultyCache,
                originValidator: () => true
            });
            // Should not throw, should continue without caching
            const context = { iss: 'https://example.com', kid: 'test-key' };
            const jwksGetter = await faultyNoWay.resolveJWKS(context);
            expect(jwksGetter).toBeDefined();
            expect(typeof jwksGetter).toBe('function');
        });
    });
});
